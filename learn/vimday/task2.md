## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：B  
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

5. 以下关于mapping的叙述错误的是：C  
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）
   - `require`：用于检查函数参数或状态变量的有效性，失败时会退还剩余Gas。
   - `assert`：用于检查不应该发生的条件（如内部错误），失败时不会退还Gas。(Solidity 0.8.0之前失败时消耗所有gas,0.8.0 之后会退还部分 gas)
   - `revert`：用于手动回滚交易，通常与`require`结合使用，也会退还剩余Gas。

7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

```
 在Solidity中，合约继承遵循C3线性化（C3 Linearization）规则，确保合约的继承关系是单一确定的，并按最远的基类优先（Depth-First, Right-to-Left）解析函数调用。

C继承了A和B，并重写了foo()，并在override(A, B)指定了需要覆盖的父合约。

因此，在C3线性化中，B的foo()比A的foo()优先。

如果C没有重写foo()，C.foo()调用时会遵循C3线性化顺序，先检查B是否有foo()，如果有就调用B的foo()，否则才会调用A的foo()。

由于C已经显式重写了foo()，那么C.foo()会直接执行C自己的实现，不会自动调用A或B的版本，除非在C.foo()里显式调用super.foo()。
```
8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

- `(1)` 使用`call`方法发送ETH时，调用者可以指定Gas限制，并且可以处理返回值。
- `(2)` 使用`transfer`方法发送ETH时，Gas限制是固定的（2300 Gas），并且不允许处理返回值。
- `call`方法更灵活，但也更容易引入安全风险（如重入攻击），而`transfer`方法相对安全，但不够灵活。
- 在实际开发中，推荐使用`call`方法，并在调用时显式处理返回值和错误。
- 另外，`transfer`方法在失败时会抛出异常，而`call`方法则返回布尔值，开发者需要自行处理错误。
- 需要注意的是，`call`方法在Solidity 0.8.0版本后，默认会抛出异常，而不是返回布尔值。
- 这使得`call`方法在处理失败时更为一致，避免了开发者忽略错误处理的风险。

