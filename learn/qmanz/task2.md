# 第二章：Solidity 快速入门

## 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
3. 当合约收到不带任何数据的以太转账时，会自动触发`fallback`函数。  

---

## 二、选择题

1. 函数选择器(selector)的计算方法是：  ​B 函数名哈希的前4字节
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

2. 以下关于mapping的叙述错误的是：  C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

## 三、简答题

### 1.请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）

#### require()
* * * * * * * * * * * * * * * * * * * * * * *

* **触发条件**:主要用于验证外部输入或前置条件是否满足,如用户输入参数是否合法,外部协议响应是否正确等.
* **Gas退还**:当条件不满足时,会回滚所有状态变更,并将剩余 Gas退还给调用者.
* **典型应用**:通常放在函数的开头,用来确保执行前的必要条件.

#### assert()
* * * * * * * * * * * * * * * * * * * * * * *

* **触发条件**:主要用于检测内部逻辑是否正确,如防止溢出/下溢,验证不变量等.
* **Gas退还**:当断言失败时,会回滚所有状态变更,但不会退还 Gas.
* **典型应用**:通常放在函数的结尾,用来确保程序逻辑的正确性.

#### revert()
* * *

* **触发条件**:主要用于手动触发异常,适用于复杂的逻辑判断.
* **Gas退还**:当执行到 revert语句时,会回滚所有状态变更,并将剩余 Gas退还给调用者.
* **典型应用**:可用于替代 require实现更灵活的错误处理.

#### 总结
require:验证外部输入/前置条件,Gas可退.
assert:检测内部逻辑,Gas不退.
revert:手动触发异常,Gas可退.


### 2. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```
实际执行时会调用哪个父合约的函数？为什么？

在 Solidity 中，当合约 `C` 继承 `A` 和 `B`，并且两者都定义了 `foo()` 函数时，`C` 必须显式地 `override(A, B)` 来解决继承冲突。那么，实际执行时 `C.foo()` 的行为取决于 Solidity 的**线性化继承顺序（C3 线性化算法）**。

 **继承解析**
Solidity 采用 **从右到左的继承顺序** 来构建一个继承链，即 **最右边的父合约会被最先解析**。其线性化顺序是：
```
C → A → B
```
意味着：
1. `B` 先被解析，`A` 在 `B` 之后。
2. `C` 继承 `A` 和 `B` 时，最终执行的是 `A` 里的 `foo()`，因为 `A` 出现在 `B` 之后。

 **执行优先级**
当 `C.foo()` 被调用时：
- `C` 继承了 `A` 和 `B`，但 `C3` 线性化规则会确保 `C` **优先从左侧继承的合约（`A`）寻找 `foo()`**。
- 所以，最终 `foo()` 的执行顺序是 **合约 `A` 的 `foo()` 版本**。



### 3. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

`call` 和 `transfer` 在发送 ETH 时有**本质的安全性和 gas 处理上的区别**，主要涉及 **gas 限制、异常处理和重入攻击**，具体如下：

---

#### **1. `addr.call{value: 1 ether}("")`**
```solidity
(bool success, ) = addr.call{value: 1 ether}("");
require(success, "Transfer failed");
```
##### **特点**
- **返回值**：`call` 返回 `(bool, bytes memory)`，表示是否成功执行。
- **Gas 处理**：**不会限制 gas**，目标地址的 `fallback` 或 `receive` 函数可以消耗较多的 gas。
- **异常处理**：`call` **不会自动回滚**，需要手动 `require(success)` 处理。
- **推荐使用场景**：
   - 适用于可升级合约、灵活合约调用。
   - 需要手动检查 `success` 以确保转账成功。

---

#### **2. `addr.transfer(1 ether)`**
```solidity
addr.transfer(1 ether);
```
##### **特点**
- **Gas 处理**：`transfer` **限制了 2300 gas** 供目标地址的 `receive()` 或 `fallback()` 执行，防止恶意合约执行高成本操作。
- **异常处理**：如果 `addr` 失败（例如 `receive()` 或 `fallback()` 消耗过多 gas），`transfer` **会自动回滚交易**，不用额外检查。
- **安全性**：
   - **防重入攻击**：因为 `transfer` 限制了 2300 gas，不允许合约内执行复杂逻辑（如再次调用外部合约）。
   - 但是 `transfer` **不适用于所有情况**，如果 `addr` 是一个需要较多 gas 处理的合约（比如升级代理合约），则可能导致交易失败。

---

#### **核心区别**
| 方式            | Gas 限制 | 异常处理  | 防重入攻击 | 适用场景 |
|---------------|---------|----------|----------|----------|
| `call{value}` | 无限制  | 需手动检查 | 可能受影响 | 低级转账、合约调用 |
| `transfer`    | 限制 2300 gas | 自动回滚 | 更安全 | 确保安全的简单转账 |

---

#### **实际开发建议**
1. **推荐使用 `call{value}`，并手动检查 `success`**，因为 `transfer` 在某些情况下会因为 gas 限制导致失败。
2. **避免直接使用 `transfer` 进行 ETH 发送**，因为未来的 EIP 可能会修改 gas 费用，2300 gas 可能不够，导致转账失败。
3. 如果担心**重入攻击**，使用 `ReentrancyGuard` 或 `checks-effects-interactions` 模式来规避。

---

#### **总结**
- `transfer` 更安全，但受 2300 gas 限制，适用于简单转账。
- `call{value}` 更灵活，但需要手动检查 `success`，适用于复杂合约交互。
- **现代 Solidity 开发推荐使用 `call{value}` 而非 `transfer`**，但必须做好异常处理和重入保护。
