## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`fallback`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是： B 
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

5. 以下关于mapping的叙述错误的是： C 
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）

require:
触发条件：通常用于输入验证或合约执行条件检查，确保传入的参数或合约状态是有效的。
Gas 退还：如果 require 触发错误，消耗的 Gas 会退还。

assert:
触发条件：用于检查合约内部逻辑的错误，通常用于不应发生的情况，比如合约状态异常或不一致。
Gas 退还：assert 失败时，所有已消耗的 Gas 都不会退还。

revert:
触发条件：用于手动回滚交易，可以带有错误消息，通常用于合约中的条件不满足时回滚操作。
Gas 退还：与 require 类似，revert 失败时，已消耗的 Gas 会退还。

7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

在 Solidity 中，当子合约同时继承多个父合约且父合约中存在相同函数时，调用的函数是基于继承顺序的。如果子合约中没有显式调用哪个父合约的函数（如 override），则会优先调用第一个继承的父合约中的函数。

在本例中，合约 C 继承 A 和 B，foo() 函数会优先调用父合约 A 中的实现，除非显式指定。

8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```
(1) addr.call{value: 1 ether}("")

这是低级的 call 方法，直接与目标地址进行交互，并通过 value 发送指定数量的以太币。call 是一种低级的接口，允许发送以太币并执行代码，可以接受任何函数签名。

call 是不安全的，因为它没有类型检查和自动保护机制。使用时要小心可能的重入攻击。

(2) addr.transfer(1 ether)

transfer 是一个相对较安全的方法，用于将以太币发送到指定地址，并且自动限制了 Gas 消耗为 2300 Gas。transfer 会抛出异常（如果失败），并且不能进行复杂的执行逻辑，因此它相对更安全，不容易引发重入攻击。

本质区别：

call 具有更大的灵活性，但风险也更高，因为它允许执行任意代码并且没有强制的 Gas 限制。

transfer 更安全，但功能受限，且发送的 Gas 数量较少。
