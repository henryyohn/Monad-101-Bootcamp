## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：  B   
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

6. 以下关于mapping的叙述错误的是：  C  
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）
   `require`：用于输入验证和前置条件检查（如余额不足），条件不满足时退还剩余Gas，触发普通错误。  
   `assert`：检测代码逻辑错误（如溢出/状态矛盾），失败时不退还Gas，表示合约存在严重漏洞。  
   `revert`：主动终止执行并回滚，可自定义错误信息，Gas退还规则与`require`相同，常用于复杂条件判断。 


7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

   调用B的foo()。因为继承列表中右侧的合约（B）优先级更高，覆盖左侧（A）的同名函数。执行顺序由合约继承的线性化顺序决定。此例中C is A, B，Solidity采用C3线性化规则，实际继承链为C -> B -> A

8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```
错误处理：
   transfer失败时自动回退交易（revert），消耗所有已用Gas；
   call失败仅返回false，需手动检查返回值，否则继续执行。

Gas限制：
   transfer固定分配2300 Gas（防重入但可能不足）；
   call默认转发全部剩余Gas（易引发重入攻击，需主动限制）。
