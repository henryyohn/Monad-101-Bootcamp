## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity 中存储成本最高的变量类型是`_storage__`变量，其数据永久存储在区块链上。
2. 使用`_constant__`关键字声明的常量可以节省 Gas 费，其值必须在编译时确定。
3. 当合约收到不带任何数据的以太转账时，会自动触发`_receive__`函数。

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：B  
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前 4 字节  
   **C)** 函数参数的 ABI 编码  
   **D)** 函数返回值的类型哈希

5. 以下关于 mapping 的叙述错误的是：C  
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套 mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和 Gas 退还角度）

   `require`

   - 使用场景：
     - 用于验证输入参数、条件检查
     - 用于验证外部合约调用的返回结果
     - 适用于可预见的、常规的错误检查
   - Gas 处理：
     - 会退还剩余的 gas 给用户
     - 更加节省 gas（比 assert 消耗更少）

   `assert`

   - 使用场景：
     - 用于检查内部错误
     - 验证不变量（invariants）
     - 检查不应该发生的条件
   - Gas 处理：
     - 消耗所有剩余的 gas
     - 不会退还剩余 gas

   `revert`

   - 使用场景：
     - 用于复杂条件判断的情况
     - 需要提供详细错误信息时
     - 在深层嵌套的代码中需要直接退出
   - Gas 处理：
     - 会退还剩余的 gas 给用户
     - 与 require 类似

7. 某合约同时继承 A 和 B 合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

调用顺序：

- 在合约声明 contract C is A, B 中，最右边的合约 B 优先级最高
- 因此，如果 foo() 函数在 A 和 B 中都存在，默认会调用 B 合约中的 foo() 函数

  原因：

- Solidity 使用 C3 线性化算法来解决多重继承时的函数调用顺序
- 继承声明中的顺序从左到右表示从最基础到最特殊
- 最右边的合约被认为是最特殊的实现，因此会覆盖左边合约的同名函数

8. 当使用`call`方法发送 ETH 时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

call 和 transfer 这两种发送 ETH 的方法有以下几个本质区别：

- Gas 限制：
  - transfer：固定 2300 gas 限制
  - call：可以转发所有可用 gas，或自定义 gas 限制
- 错误处理：
  - transfer：失败时会自动 revert 交易
  - call：返回布尔值表示成功或失败，需要手动检查返回值并处理错误
- 安全性考虑：
  - transfer：由于 gas 限制，更安全但功能受限
  - call：更灵活但需要注意重入攻击风险
- 推荐使用：

  现代合约开发推荐使用 call，因为：

  transfer 的 2300 gas 限制可能因为 gas 成本变化而导致转账失败

  call 提供更好的灵活性和可控性

  但使用 call 时必须：

  - 检查返回值
  - 实现重入保护
  - 遵循安全开发最佳实践
