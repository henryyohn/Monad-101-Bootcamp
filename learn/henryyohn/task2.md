## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`__storage_`变量，其数据永久存储在区块链上。
```
说明：storage 变量永久存储在区块链上，需要消耗大量的 Gas 费用
```
2. 使用`_constant__`关键字声明的常量可以节省Gas费，其值必须在编译时确定。
```
说明：constant 变量在编译时就必须确定其值，并且不能被修改
```
4. 当合约收到不带任何数据的以太转账时，会自动触发`__receive()_`函数。
```
说明：这是 Solidity 0.6.0 版本后引入的特殊函数
```

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：B
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  
```
答案： B
函数选择器是函数签名的 keccak256 哈希值的前 4 个字节；
函数签名格式为：函数名(参数类型1,参数类型2,...)
```

5. 以下关于mapping的叙述错误的是：C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  
```
答案： C
mapping 不能直接获取长度，可以使用可迭代的 mapping 模式来获取

```

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）
- require
  - 用于检查输入参数和外部条件
  - 会退还剩余的 Gas 费用
  - 适合用于检查用户输入和外部条件
- assert
  - 用于检查内部错误和不变性条件
  - 不会退还 Gas 费用
  - 适合用于检查合约内部状态
- revert
  - 直接回滚交易
  - 会退还剩余的 Gas 费用
  - 可以自定义错误信息


7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

```
答案：
实际执行时会调用 B 合约的 foo() 函数
原因：
Solidity 的继承顺序是从右到左的，B 的优先级高于 A
使用 override(A,B) 表示这个函数重写了两个父合约的函数
```


8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

```
答案：
transfer 是 Solidity 0.6.0 之前推荐的方式，有固定的 Gas 限制（2300 gas）

call 更灵活，可以：
1、自定义 Gas 限制
2、发送任意数据
3、返回执行结果
4、是当前推荐的方式

安全性：transfer 在失败时会抛出异常，而 call 需要手动检查返回值
```
