## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`receive()`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：B
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

5. 以下关于mapping的叙述错误的是：C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）

`require`、`assert`和`revert`的使用场景差异如下：

- **require**：
  - 使用场景：用于验证输入条件或外部调用的返回结果，属于可预见的错误处理
  - Gas退还：会退还剩余的gas
  - 错误代码：可以提供自定义错误信息
  - 示例用途：参数验证、权限检查、状态条件验证

- **assert**：
  - 使用场景：用于检查内部错误和不变量，表示不应该发生的情况
  - Gas退还：在Solidity 0.8.0之前不退还gas，0.8.0之后会退还剩余gas
  - 错误代码：触发Panic错误，不提供自定义错误信息
  - 示例用途：防止溢出（0.8.0前）、逻辑不变量验证、防止不可能状态

- **revert**：
  - 使用场景：用于复杂条件判断后的错误处理，或需要提供更多错误信息时
  - Gas退还：会退还剩余的gas
  - 错误代码：可以提供自定义错误信息，支持自定义错误类型
  - 示例用途：复杂条件判断、需要自定义错误类型的场景


7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

会调用最右侧父合约（即B合约）的`foo()`函数，因为Solidity使用C3线性化算法确定继承顺序，最右侧的合约在继承链中优先级最高。在声明`contract C is A, B`时，B是最右侧的合约，因此B合约的函数会先被调用。

8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

这两种发送ETH的方式有以下本质区别：

- **Gas限制**：
  - `transfer`固定提供2300 gas，仅够执行基本操作，不足以执行复杂逻辑或存储操作
  - `call`转发所有可用gas（可通过gas参数自定义），能支持接收方执行复杂逻辑

- **错误处理**：
  - `transfer`失败时会自动revert整个交易，提供了内置的安全保障
  - `call`返回布尔值表示成功/失败，不会自动revert，需要调用方手动检查返回值并处理错误

- **重入攻击风险**：
  - `transfer`的gas限制使得重入攻击风险较低（接收方难以执行复杂逻辑）
  - `call`允许接收方使用全部gas，可能导致重入攻击，使用时应当遵循checks-effects-interactions模式

- **兼容性**：
  - `transfer`在某些情况下可能失败（如接收方合约的fallback/receive函数消耗过多gas）
  - `call`更灵活，是当前推荐的发送ETH方式，特别是在与未知合约交互时

总结：`transfer`更安全但限制更多，`call`更灵活但需要开发者自行处理安全问题。现代Solidity实践中通常推荐使用`call`并遵循重入保护模式。

