## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：  
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

答案：B。函数选择器是函数签名的keccak256哈希值的前4个字节。

5. 以下关于mapping的叙述错误的是：  
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

答案：C。mapping是无法获取长度的,因为它不存储键的列表。

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）

- require：用于验证输入参数或外部条件。条件不满足时会回退交易并退还剩余gas。适用于可恢复的错误检查。
- assert：用于检查内部错误和不变量。触发时会消耗所有gas。用于捕获不应该发生的严重错误。
- revert：用于主动触发回退。会退还剩余gas。适用于需要主动终止执行并返回错误信息的场景。


7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

在Solidity中,继承顺序遵循C3线性化算法,最右边的合约具有最高优先级。在这个例子中,合约C继承时声明的顺序是A、B,所以B合约是最右边的,因此会调用B合约的foo()函数。这种机制确保了继承关系中函数调用的明确性和可预测性。


8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

这两种方法有以下本质区别：

1. Gas限制：
   - transfer固定使用2300 gas,仅够执行基本的接收逻辑
   - call可以转发所有可用gas,或通过gas选项自定义

2. 错误处理：
   - transfer失败时会抛出异常,导致整个交易回滚
   - call失败时返回false,允许调用者自行处理错误

3. 安全性：
   - transfer更安全,因为gas限制防止重入攻击
   - call更灵活但需要手动实现重入保护

推荐使用call并遵循checks-effects-interactions模式来处理ETH转账。

