## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发'receive()'函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：  A
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

5. 以下关于mapping的叙述错误的是：  C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）
（1）require
	触发条件
	用于前置条件检查，验证输入参数或合约状态的合法性（如用户权限、参数有效性等。

	Gas 退还
	触发时通过 REVERT 操作码回滚，退还所有未使用的Gas。这是为了鼓励开发者合理验证外部输入，避免无效交易浪费网络资源。
（2）assert
	触发条件
	用于后置条件检查和不变量验证，确保合约内部状态始终一致（如数值计算后余额非负）。若触发，表明代码存在逻辑错误。

	Gas 退还
	触发时通过 INVALID 操作码回滚，消耗所有剩余 Gas。这是为了惩罚开发者未正确处理内部错误，强调此类问题需在测试阶段解决。
（3）revert
	触发条件
	灵活回滚机制，常用于复杂逻辑中的条件判断（如 if/else 分支）。可直接使用或配合自定义错误（如 revert CustomError()）提高 Gas 效率。

	Gas 退还
	与 require 相同，通过 REVERT 操作码回滚，退还未使用的 Gas。

7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？
	执行的是foo()函数
	原因：override关键字重载父类foo实现

8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```
在 执行机制、Gas 限制、安全性 和 异常处理 上有本质区别
执行机制：
	transfer：无法进行复杂操作，仅够执行基本日志记录，底层操作码是call+自动回滚；
	call方法：默认传递所有剩余gas,可能导致重入攻击，底层操作码是call+需手动检查；
Gas限制：
	transfer：固定Gas；
	call方法：无固定Gas限制；
安全性：
	transfer：重入攻击风险低，Gas不足限制重入，适用于简单转账、兼容合约；
	call：重入攻击风险高，需要手动限制Gas和重入防护，适用于灵活交互、自定义逻辑；
异常处理：
	transfer：直接回滚整个交易，无返回值
	call：继续执行后续代码，返回bool success