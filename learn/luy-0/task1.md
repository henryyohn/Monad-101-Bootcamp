# 第一章：走进 Web3 世界

## 简单描述一下本地开发、部署合约的流程

Web3 开发架构与传统的开发架构的显著不同点在于, Web3 开发并没有传统意义上的中心化服务端. 而是由区块链担任了传统服务端的角色, 前端直接与链上进行交互实现逻辑运算. 

> 目前由于成本等问题, 大部分项目还是存在传统服务端, 只是用于将其中部分放在链上. 

由于这一差异(传统服务端&链上)存在, 导致链上合约虽然作为运算逻辑的承载者, 但存在与传统互联网截然不同的开发部署流程.

1. 环境搭建. 开发时使用合约专属的开发工具. 包括 最简单的网页式 remix 以及 Hardhat/Truffle
   > Remix 是一个网页版的合约开发工具. 允许用户便捷地编写合约, 并且一键部署/测试, 适合初学者快速验证. 
   > Hardhat 本质是一个合约开发脚手架. 允许用户在本地快捷生成合约项目, 并在编写合约后即时编译和测试. 它内置了 Hardhat Network, 是一种本地以太坊网络, 允许开发人员在本地计算机上部署合约、运行测试和代码调试，无需连接到真实的以太坊网络。其文档和社区支持针对的是广泛的 JavaScript 开发者群体。
   > Foundry 是一套集成的智能合约开发工具链，旨在简化以太坊智能合约的编译、部署和测试流程。其底层使用 Rust 因此更加高效. 测试脚本都是使用 Solidity 编写.
2. 合约编写+本地测试. 使用 Solidity 编写合约代码, 并使用开发工具进行本地测试. 
   > 存疑: 合约开发中的本地测试与传统的本地测试有何异同? 特别是由于合约部署后的不可更改性, 必然要求对于其安全性, 性能, Gas费消耗速率等有着高要求. 是否存在一套完整 SOP 来规范测试? 又如何保证测试/最终效果? 
   > 本地测试又可以仿照传统测试理论, 区分为单元测试(单个合约有效性验证), 集成测试(多个合约间交互), 系统测试(在测试网完全模拟主网环境进行整体测试)
   > 由于传统 hotfix 几乎不存在, 必须保证在测试时覆盖所有的边界条件 (我个人感觉这一限制非常反人类)
   > 由于 Gas 费的消耗, 需要优化其合约编写方式(例如避免循环), 并测试不同输入下的消耗
   > 由于合约基本都直接涉及到金钱, 对于其安全性保障非常之高. 需要额外进行攻击性测试
3. 编译. 由于 EVM 仅能支持字节码, 我们需要指定编译器版本并将合约代码编译为 ABI (类似API, 对外接口) 和 字节码(实际运行的二进制文件) 
4. 部署. 首先选择好需要部署的网络(例如 EVM 主网, 或其他) 由部署者账户(owner)向链上发送部署交易(需要支付gas费) 部署完成后即可获取部署好的合约地址, 前端可以进行调用.
5. 前端开发. 根据合约地址和ABI合约接口, 使用前端库(例如 Web3.js/Ethers.js )与链上交互, 调用合约函数. 


## 简单描述一下用户在使用一个 DApp 时与合约交互的流程

正如上一题中所言, Web3 的交互方式是前端-链上. 规避了传统的 CDN/Server 等环节. 因此交互流程有所不同. 

1. 前端交互. 首先, 用户实际交互的依旧是前端页面. 但前端并非是通过 API 来进行通信, 而是使用 JSON-RPC协议（如eth_sendTransaction）完成, 进行前端代码发送二进制编码数据与链上的交互（非HTTP规范）。错误码为EIP-1474定义. 

2. 用户授权. 这一通信首先要求用户存在该网络的钱包地址, 并授权 DAPP相关权限. 用户使用钱包插件(例如MetaMask)进行授权, 这一步会由前端通过 window.ethereum API 请求钱包签名，验证用户所有权。
> ToLearn: 具体的钱包签名接口定义, 使用方式与背后原理

3. 钱包处理. 授权后试图进行操作链上信息(访问/交易)时, 由前端构造交易数据 (包括目标合约、函数、参数), 调用钱包; 钱包插件跳出弹窗, 现实所需要交易费用(Gas费/Priority Fee) ; 用户确认授权(钱包使用用户私钥对交易信息加密); 钱包将签名交易广播发送到连接的节点, 等待节点接受并响应

4. 链上交互. 
    - 节点接收: 用户将交易广播到该网络的节点上, 节点验证交易信息的格式(Nonce、Gas Limit 是否合法)
    - 待处理交易池: 验证后的交易会进入待处理交易池(Mempool) 等待矿工（PoW）或 验证者（PoS）选择交易. 此时高 Gas 费的交易请求会被优先处理.
    - 合约执行: 节点执行合约代码; 执行时会按 OP Code 计算 Gas，从用户钱包扣除。
    - 区块确认: 交易被处理并写入区块，广播到全网. 其他节点验证区块合法性. 当 12 个区块确认(以以太坊为例)交易被视作最终确认(Finality)

> Detail: 
> - 什么是链上节点? 是以太坊节点吗? 如果某个链声称自己兼容以太坊, 那么它可以直接使用以太坊的节点来通信吗?
> 并不可以,兼容以太坊仅代表 API接口和ABI与以太坊对齐, 实际还是需要 部署自身节点网络.
> - 如果某个链的节点过少, 会带来什么后果(响应时间变慢吗)
> 单点故障风险增加; 交易广播延迟（需更多跳转）; 数据可用性依赖少数节点（违背去中心化原则）

5. 前端更新
   - 监听事件: 前端通过 web3.js 订阅监听链上的合约事件（如 Transfer）。
   - 交易回执: 区块确认后，前端获取交易哈希（TX Hash）
   - 前端继续业务逻辑
> Detail: 
> - 如果交易过程中发生了页面刷新, 前端丢失了当前状态会发生什么? 如何保证幂等性?
> 如果交易未被广播出去, 前端未记录交易哈希，此时刷新将导致交易完全中断. 需要重新发起交易.
> 如果已经广播出去, 但交易仍在进行中. 交易本身有唯一的交易哈希标记, 链上交易的生命周期独立于前端状态. 交易会继续处理(不论前端页面是否关闭). 
> 前端需要自己本地缓存交易哈希, 并在重新加载后继续监听事件/检查交易状态. 如果缓存被清除, 那么就会丢失本次的交易记录. 
> 用户可以使用区块链浏览器或者钱包历史查询自己的历史交易记录查看状态. 
> - 如何避免重复交易? 如何保证幂等性? 
> 同一地址的请求必须保证 Nonce 的有序递增. 如果前序交易请求未完成会阻塞后续请求. 
> 在这个例子中, 如果用户重复发起交易(不论是用户多次点击还是网络原因导致) 相同的Nonce会保证不被处理第二次, 保证幂等性. 此外, 还可以调高 Fee 的方式来替换前一笔相同Nonce的交易, 称为 RBF（Replace-By-Fee）
> - 交易回执是什么? 前端获取交易哈希中能得到什么信息? 这些信息会被如何处理 有什么用?
> 包括本次交易请求的状态与交易细节, 例如实际消耗 Gas 等. 用于后续业务逻辑.






## 通读「区块链黑暗森林自救手册」，列出你觉得最重要的三个安全技巧

[「区块链黑暗森林自救手册」](https://github.com/slowmist/Blockchain-dark-forest-selfguard-handbook/blob/main/README_CN.md)

