## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：  B
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

5. 以下关于mapping的叙述错误的是：  C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）
   1) require
   触发条件：require用于验证外部输入或条件是否满足，如果不满足则抛出错误。它通常用于输入验证、条件检查或合约的前置条件（如函数调用前的检查）。
   Gas 退还：当require条件失败时，所有已消耗的Gas会被退还，且状态不会改变。也就是说，调用者支付的Gas会被退回。
   2) assert
   触发条件：assert用于检查不应该失败的条件，通常用于内部错误检查或代码不一致性。
   Gas 退还：当assert条件失败时，所有Gas会被消耗，且状态会被回滚（与require类似）。但是assert是用于错误检查的最后防线，因此失败时合约的状态可能会受到损害。
   3) revert
   触发条件：revert 用于显式地回滚整个交易，通常是由开发者明确调用的。revert可以携带错误消息，并且可以在合约中调用，以回滚状态并退还Gas。
   Gas退还：当revert被触发时，所有Gas都会退还，并且状态会回滚。与require不同，revert允许开发者自定义错误消息。

7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？
答：在 Solidity 中，默认情况下，当子合约同时继承多个父合约且这些父合约都有相同的函数时，会按照继承顺序调用第一个父合约的函数，所以优先执行A的foo方法

8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

答：
   1) call
      call是一种低级的函数调用方法，可以用来向合约或外部地址发送 ETH。
      它的语法允许传递value和执行额外的操作（例如调用函数，发送数据）。
      call是低级的，它不会自动对接收方的 fallback或receive函数进行限制，因此它能够处理任何外部合约的调用。
      call方法返回一个布尔值，指示操作是否成功（true或false），但是它并不会自动抛出异常，因此你需要显式地检查返回值来确定操作是否成功。

   2) transfer
      transfer是一种更安全且高层的发送ETH方法，通常用于发送简单的ETH交易。
      transfer默认将2300 Gas限制应用于接收方（合约或地址）的receive或fallback函数，这样可以防止接收方执行复杂操作（例如递归调用）并降低重入攻击的风险。
      如果接收方的操作失败（例如receive或fallback函数抛出异常），transfer会自动抛出异常并回滚交易。
