## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`_storage__`变量，其数据永久存储在区块链上。  
2. 使用`_constant__`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`_receive__`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：  B
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

5. 以下关于mapping的叙述错误的是：  C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）
   `require`用于验证输入条件、外部调用返回值或函数预期状态，如果条件不满足，则触发`require`, 退还剩余的未使用Gas.
   `assert`用来捕捉编程错误，当条件不满足时，表明合约内部出现严重错误，此时EVM会触发一个Panic类型的错误，并消耗所有剩余的Gas.
   `revert`当出现一些业务逻辑无法继续或检测到异常状态时，直接调用`revert()`，退还剩余的未使用Gas


7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

   实际执行时会调用B合约的函数，C没有实现自己的foo()函数，而是沿着继承链向上寻找，B在A前，所以会调用B合约的foo()函数

8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```
`call`
   - 安全性：调用失败时不会自动回滚，需要显式检查返回值
   - Gas限制：没有严格的Gas限制，允许接收方消耗更多的Gas
`transfer`
   - 安全性：失败自动回滚交易
   - Gas限制：有严格的Gas限制，不能消耗太多的Gas
