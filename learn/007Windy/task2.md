## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：  B
   
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

5. 以下关于mapping的叙述错误的是：  C
    
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

 ##### (解释：_mapping没有 length 属性_ ) #####
---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）
- require是验证输入参数或者其他条件，当不满足时，退还部分gas费用，终止执行，抛出错误信息；
- assert用于检查代码的不变量，适合检查始终应该为true的属性或者条件，一旦出现false的情况，意味着代码出现严重错误，终止执行，不会退还gas费用，需要重新审查和修复代码；
- revert 和 require类似，是用于手动触发异常检查，可以自定义各种条件和验证规则，非常灵活，适用于复杂的验证情况，条件判断不满足时，终止函数执行，退还部分gas费用。


7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？


回答：执行C合约自定义的方法，使用override关键字重写了这个函数。


8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

回答：call是一个底层方法，使用比较灵活，返回一个布尔值来表示调用是否成功，需要手动检查返回值来处理错误情况，需要手动控制发送gas数量，否则会把剩余的所有gas传给目标地址
transfer会自动处理异常情况，发送失败时会抛出异常，使当前函数执行终止，传输gas固定在2300，防止目标地址接受函数执行复杂操作
