## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity 中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。
2. 使用`constant`关键字声明的常量可以节省 Gas 费，其值必须在编译时确定。
3. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：B
   **A)** sha3(函数签名)
   **B)** 函数名哈希的前 4 字节
   **C)** 函数参数的 ABI 编码
   **D)** 函数返回值的类型哈希

5. 以下关于 mapping 的叙述错误的是：C
   **A)** 键类型可以是任意基本类型
   **B)** 值类型支持嵌套 mapping
   **C)** 可以通过`length`属性获取大小
   **D)** 无法直接遍历所有键值对

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和 Gas 退还角度）

   - `require`: 第一个参数是条件, 如果为 `false` 则触发, 第二个参数为错误描述(可以省略), 会退还 gas, gas 随描述的长度增加
   - `assert`: 程序断言, 参数为条件, 如果为 `false` 则触发, 0.8.0 之前的版本会消耗所有 gas
   - `revert`: 可以手动触发错误, 参数为错误描述, 一般也可以用来 `revert` 自定义的 `Error`, 节省 gas

7. 某合约同时继承 A 和 B 合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

- C 合约自己的 `foo` 函数
- 因为 C 合约继承了 A 和 B 合约并重新了 `foo` 函数, 所以会调用 C 合约自己的 `foo` 函数

8. 当使用`call`方法发送 ETH 时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

- (1) :
  - 没有 gas 限制, 也可以手动指定 gas
  - 会返回一个布尔值, 表示是否调用成功, 如果调用失败, 不会自动回滚, 须要手动回滚
  - 接收方的 `receive` 和 `fallback` 函数可以支持复杂的逻辑
- (2):
  - 2300 gas 限制
  - 会直接调用, 如果调用失败, 会回滚交易
  - 接收方的 `receive` 和 `fallback` 函数不能有复杂的逻辑
