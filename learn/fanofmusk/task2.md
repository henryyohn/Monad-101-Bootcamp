## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity 中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。
2. 使用`constant, immutable`关键字声明的常量可以节省 Gas 费，其值必须在编译时确定。
3. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。

---

### 二、选择题

4. 函数选择器(selector)的计算方法是： B
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前 4 字节  
   **C)** 函数参数的 ABI 编码  
   **D)** 函数返回值的类型哈希

5. 以下关于 mapping 的叙述错误的是： C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套 mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和 Gas 退还角度）

                require	            assert	      revert
​​触发场景​​	外部输入/前置条件验证	内部逻辑/不变量验证	  主动回滚/复杂条件处理
​​Gas 退还​​	✔️ 退还未使用的 Gas	 ❌ 不退还 Gas	 ✔️ 退还未使用的 Gas
​​适用错误​​	预期内的错误（用户输入错误）	预期外的错误（合约逻辑错误）	灵活处理（自定义错误/分支逻辑）
​​推荐用途​​	输入验证、状态检查	 调试、数学约束、后置条件	 复杂逻辑回滚、优化 Gas 成本

7. 某合约同时继承 A 和 B 合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

声明顺序​​：Solidity 的继承链遵循 ​​从右到左的线性化规则​​（类似 Python 的 C3 算法）。
在 contract C is A, B 中，父合约的继承顺序为 A → B（注意：​​先声明 A，后声明 B，但实际 MRO 是反向的​​）。
​​方法解析顺序（MRO）​​：
最终 MRO 为 C → B → A，即：
子合约 C 的函数优先级最高；
其次是最后声明的父合约 B；
最后是第一个声明的父合约 A。

8. 当使用`call`方法发送 ETH 时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

特性	transfer(1 ether)	call{value: 1 ether}("")
​​Gas 限制​​	固定 2300 Gas	可自定义（默认全部剩余 Gas）
​​异常处理​​	自动回滚	需手动检查返回值
​​安全性​​	防重入（因 Gas 不足）	需开发者自行防护（如防重入锁）
​​适用场景​​	简单转账（EOA 或 Gas 需求低的合约）	需灵活 Gas 或复杂交互的合约

